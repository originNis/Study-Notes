# 第一章

## 性能

提高计算机性能：

- 半导体技术进步：特征尺寸、主频
- 计算机体系结构改进

利用ILP提升性能达到瓶颈，提高性能新途径：

- DLP
- TLP
- RLP

## 弗林分类法

- **SISD**
- **SIMD**
  - 向量机
  - GPU
- **MIMD**
  - 紧耦合MIMD
  - 松耦合MIMD
- **MISD**
  - 无商业产品

## 功率与能耗

热设计能耗（TDP）：

- 表示持续的功耗，低于峰值功率高于平均功率
- 为了处理器正常工作，电源功率与冷却系统功率需要与TDP匹配

可以通过动态调整时钟主频来限制功耗

一项工作能耗=执行该工作的平均功率X执行时间

> 功耗是更好的衡量指标

单个晶体管动态能耗**（晶体管状态转换1->0，0->1所需要的能耗）**

> $能耗_{动态}\propto容性负载*电压^2$

单个晶体管动态功率

> $功率_{动态}\propto\frac{1}{2}容性负载*电压^2*开关频率$

对一项工作：减少频率等于减少功率但不能减少能耗

## 系统可信度

系统模块的可信度由可靠性和可用性衡量

**模块可靠性**：从某个参考时刻开始的连续实现服务时间

- MTTF：平均无故障时间
  - MTTF的导数是故障率
- MTTR：故障平均修复时间，服务中断度量
- MTBF：平均故障间隔时间 = MTTF + MTTR

模块可用性：当模块在服务完成与服务中断两种状态间切换，服务完成占据的比例

计算公式：$\frac{MTTF}{MTBF}$

## 性能测量

典型性能指标

- 响应时间：事件开始到完成的时间
- 吞吐量：在给定时间内完成的工作量

机器X相对于Y的加速比：$\frac{执行时间_Y}{执行时间_X}$

执行时间：

- 响应时间、逝去时间
  - 包含硬盘访问、内存访问、输入输出、OS时间开销等
- CPU时间（针对服务器）：只包含计算时间，不含IO操作时间开销

SPECRatio比值：将执行时间对参考机器归一化

$SPECRatio=\frac{执行时间_{参考机器}}{执行时间}$

两个机器的性能可以通过SPECRatio的比值来比较：

$\frac{SPECRatio_A}{SPECRatio_B}=\frac{执行时间_B}{执行时间_A}=\frac{性能_A}{性能_B}$

**机器执行时间与性能成反比**

单个机器的多个程序汇总性能使用几何平均$\sqrt[n]{\prod{sample_i}}$

## 计算机设计原理

利用并行性

- 多处理器、多硬盘、流水线等
- 对于服务器，将请求平衡分发到不同处理器和硬盘提升吞吐率
- 将数据分布存储到不同硬盘以便并行读写数据，实现DLP
- 对于单个处理器挖掘ILP对获得高性能很重要，比如流水线

局部性原理

- 程序趋向于充分使用最近用过的指令和数据
- 程序会将90%的执行时间花费在10%的代码上
- 根据程序近期访问来预测未来要访问的指令或数据有很高的预测准确率
- 时间局部性：近期被访问的数据和指令有可能不久会再次访问
- 空间局部性：地址邻近的数据和指令倾向于差不多时间访问

聚焦于一般情况

- 在进行涉及平衡时，优先考虑经常情况
- 在确定资源分配时采用上述原则会带来更高的性能提升

## Amdahl定律

$总加速比=\frac{原执行时间}{新执行时间}=\frac{1}{(1-升级比例)+\frac{升级比例}{升级加速比}}$

## 处理器性能公式

$CPU时间=程序的CPU时钟周期数*时钟周期时间$

$CPI=程序的CPU时钟周期数\div指令条数$

处理器性能与三个因素有关：

- 时钟周期：与硬件技术、组成有关
- CPI：与指令集架构有关
- 指令条数：与编译器、指令集架构有关

# 第二章

## 流水线技术

让多条指令重叠执行的技术

理想情况下，流水线每条指令执行时间$=非流水线单条指令执行时间\div流水线级数$

## RISC精简指令集

- 所有操作都是面向寄存器中的数据，如果数据不在寄存器需要先读入再操作
- 只有Load和Store访问内存
- 指令格式统一，只有少数几种指令格式
- 所有指令长度一致
- 指令执行过程
  - IF
  - ID
  - EX
  - MEM
  - WB

## 分支预测

- 分支预测：预测分支指令、条件指令的方向

- 动态分支预测：根据程序行为动态预测转移方向

  > 预测历史记录表
  >
  > - 一个容量很小的存储器，用分支指令的低位地址来检索访问
  > - 用1个标志位来记录最近该条指令转移成功与否
  > - 根据地址找到匹配表项，依据历史记录预测转移方向
  > - 通常采用2-bit/2位预测方法而不是上述简单1-bit/1方法
  >
  > 提高分支预测正确率的措施
  >
  > - 增加记录表大小
  >   - 当记录表大小为4K时正确率已经接近大小为无限大
  > - 使用n-bit预测方法
  >   - 采用2-bit基本上已经达到最好性能

- 静态分支预测：预测方向固定，根据编译阶段的信息来预测方向、根据早期运行情况预测方向

## 多周期操作

# 第三章

## 名称相关

两条指令使用相同的寄存器名称和相同的内存地址，却没有信息流动交换。

> 不是真实的数据相关，但会给指令重排序造成问题。

- 反相关：指令j要写某个寄存器或内存，而指令i要读相同位置并且保持初始顺序（指令i在指令j前）
- 输出相关：两条指令写同一个寄存器或内存，需要保持指令顺序

**使用重名技术解决名称相关**

## 控制相关
